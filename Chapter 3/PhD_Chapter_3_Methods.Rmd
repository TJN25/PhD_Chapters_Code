---
title: "PhD Chapter 3"
author: "Thomas_Nicholson"
date: "10/12/2021"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
library(tidyverse)
library(devtools)
library(kableExtra)

```

```{r functions, include=FALSE}
```

# Methods


## Data Selection

### Strains and experiments

How to get the summary table for the genera for the RNA-seq data:

-   Search the [SRA](https://www.ncbi.nlm.nih.gov/sra/) section of ncbi with the genus name and ['Organism'] tag.

-   Select "Send results to Run selector"

-   Select the "Metadata" button of the "Total" row and "Download" Column.

```{r summary_of_strains, echo=F, results='asis'}
load("chapter_3_files/sraDatAll.Rda")
rand.selection <- runif(5, min = 1, max = nrow(sraDatAll))
sraDatAll[rand.selection,]%>%
  kable(caption = "Table 1. List of experiments") %>%
  kable_styling()
```


The genome accession for each added genome was looked up on [NCBI](https://www.ncbi.nlm.nih.gov/) using the strain name in the file or by search for the given experiment in the [SRA](https://www.ncbi.nlm.nih.gov/sra/) section

-   Create a folder for the genus

-   Create a folder using the GenBank assembly accession e.g. `mkdir GCA_002504285.1.data/`

-   Create an experiments_list.txt file listing all of the SRA experiments to download for the given genome and save the file in the genus folder.

-   Run `callPeaksforGenome.sh -g <GCA Accession> -s`


### Subset of genomes

Two genomes from each genus (based on taxonomy information in REFSEQ95 Bacteria) were selected as a representative set of genomes.

```{r get_genomes_for_analysis, eval=F}
assembly_summary <- read.table("chapter_3_files/assembly_summary_repref.txt", sep = "\t", fill = T, quote = "", comment.char = "")
assembly_summary <- assembly_summary %>% select(V1, V5, V8, , V18, V20, V12, V6)
colnames(assembly_summary) <- c("accession.1", "type", "species", "accession.2", "genome_link", "assembly.type", "some_number")

assembly_summary <- assembly_summary %>% separate(col = species, into = "genus", sep = " ", extra = 'drop', remove = F)

all_genera <- assembly_summary %>% group_by(genus) %>% summarise(count_all = n())
dat <- assembly_summary %>% filter(assembly.type != "Scaffold")
genera <- dat %>% group_by(genus) %>% summarise(count = n())

genera <- genera %>% full_join(all_genera, by = 'genus')

complete_genomes <- assembly_summary %>% filter(assembly.type == "Complete Genome")
contigs <- assembly_summary %>% filter(assembly.type == "Contig")

complete_genomes <- complete_genomes %>%
  group_by(genus) %>%
  mutate(counter = row_number()) %>%
  filter(counter < 3) %>%
  mutate(group = "complete")

contigs <- contigs %>%
  group_by(genus) %>%
  mutate(counter = row_number() + 2) %>%
  filter(counter < 5) %>%
  mutate(group = "contig")

complete_genomes <- complete_genomes %>%
  bind_rows(contigs) %>%
  group_by(genus) %>%
  arrange(counter) %>%
  mutate(counter.2 = row_number()) %>%
  filter(counter.2 < 3)



write.table(x = complete_genomes$accession.2, file = "chapter_3_files/all_taxa_accession.txt", quote = F, row.names = F, col.names = F)
write.table(x = complete_genomes$species, file = "chapter_3_files/all_taxa_names.txt", quote = F, row.names = F, col.names = F)
```

```{r, echo=F, eval=T, results='asis'}
accessions <- read.table("chapter_3_files/all_taxa_accession.txt")
species <- read.table("chapter_3_files/all_taxa_names.txt", sep = "\t")

rand.selection <- runif(5, min = 1, max = nrow(accessions))
accessions[rand.selection,]%>%
  kable(caption = "Table 3. Accessions") %>%
  kable_styling()

rand.selection <- runif(5, min = 1, max = nrow(species))
species[rand.selection,]%>%
  kable(caption = "Table 3. Species") %>%
  kable_styling()
```


## Predicting sRNAs

***

### Download data and map reads

**Scripts involved for each Accession**

-   `callPeaksforGenome.sh -g <GCA Accession> -s`

    -   The `-s` flag is now used to indicate that a file named *experiments_list.txt* should be used for the list of RNASeq accessions.

```{bash, eval=F}
##repeat for each accession
genus="Esherichia"
accession="GCA_000017745.1"
cd RNASeq/genera/$genus/$accession.data/
callPeaksforGenome.sh -g $accession -s
```

### Call peaks on individual RNA-Seq experiments

Description:

-   A plot file is produced for each RNA-seq file.

-   The protein coding regions are ignored

### Predicting RUFs

-   `run_rnaPeakCalling.2.0.R`

    -   This runs over all current plot files in the subfolders of `RNASeq/genera/`

    -   It has everything hardcoded including file locations and no checks for overwriting existing files so before running this code
    -   Files all need to be in the correct location

### Combining GFF file


At this stage each individual RNA-Seq file has a corresponding gff file of RUFs.

-   There are 2 GFF3 files containing *known* sRNAs

    -   Downloaded GFF3 file

    -   GFF3 file from Rfam predictions

-   These GFF3 files were all combined into a single `${accession}_new_calls.txt` file.


```{bash, eval=F}
cd RNASeq/genera/
for genus in *;
do
  cd ~/phd/RNASeq/genera/${genus};
  for folder in *.data;
  do
    accession=`basename $folder .data`;
    cd ~/phd/RNASeq/genera/${genus}/${folder}/;
    combine_gff_files.R -f ./gff_files/ -o $accession;
  done;
done

```

-   These `new_calls` files are moved to `RNASeq/new_calls/`

### select random intergenic regions

-   For each sRNA that was predicted, a random intergenic region was selected for a negative control

    -   `get_random_srna_sequences.py -a <GCA Accession>`
    -   this was done by randomly selecting a start site from an intergenic region and taking the sequence from that location (for the same length as the orignial predicted sRNA).

```{bash, eval=F}
cd RNASeq/new_calls/
for file in *.txt;
do accession=`basename $file _new_calls.txt`;
  get_random_srna_sequences.py -a $accession;
done
```

## Get sRNA Sequences

Once the`${accession}_new_calls.txt` files had been made the corresponding sequences are needed.

### Predicted RUFs

The fasta files and calls files for each individual strain are all moved to a common folder `RNASeq/sequences`.

Sequences are obtained using:

-   `get_sRNA_sequences.py`

    -   Takes the coordinates and contig name and returns a DNA sequence

-   `esl-sfetch` with a `while` loop in bash for each file would be faster if this is ever redone


```{bash get_sRNA_sequences_loop, eval=F}
##repeat with seqs_random
mkdir -p RNASeq/srna_seqs/seqs_predicted/predicted
mkdir -p RNASeq/srna_seqs/seqs_predicted/positive_control
cd RNASeq/new_calls/
for file in *.txt;
do
  accession=`basename $file _new_calls.txt`;
  get_sRNA_sequences.py -a $accession;
done
```

#### Fasta files for each RUF

This step creates a fasta file for each RUF.

```{bash single_fasta_files_loop, eval = F}
group="positive_control"
cd RNASeq/srna_seqs/${group}
mkdir -p single_seqs
if [[ $group == "predicted" ]]; then
  fasta_file="predicted.fna"
elif [[ $group == "positive_control" ]]; then
  fasta_file="predicted_known.fna"
else;
  echo "${group} not a valid option for group variable"
  fasta_file=""
fi
cat GCA*.fna >> ${fasta_file}
single_fasta_files.py -i seqs_predicted/${group}/${fasta_file} -f seqs_predicted/${group}/single_seqs/
```

-------

# need to check this section

## Build models

-  The following steps are described for the `predicted` data set but this also applys to the `negative_control` and `positive_control` datasets.

-   `run_sRNA_nhmmer.sh` to loop over all sequence files and carry out an all by all search.

###Predicted nhmmer (first iteration)


```{bash run_srna_nhmmer_loop_initial, eval=F}
group="predicted"
cd RNASeq/srna_seqs/seqs_predicted/${group}
mkdir single_seqs/done/
run_sRNA_nhmmer.sh -d RNASeq/srna_seqs/seqs_predicted/${group}/predicted*.fna -f single_seqs/ -e fna
```

```{bash remove_duplicates_from_nhmmer, eval=F}

##done in ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/alignments

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/seqs_predicted/${group}/alignments

mkdir -p ignore
mkdir -p keep

for file in *.stk;
do

lines=`wc -l < $file`;
echo $lines;

if (( $lines == 0 ));  then
mv $file ignore
fi

done


for file in *.stk;
do

grep ^"#=GS" $file  | cut -d '[' -f1 | rev | cut -d ' ' -f1 | rev > move_files.txt

mv $file keep/

while read line;
do

mv $line.stk ignore/

done < move_files.txt

done

mv keep/* ./

```


### Predicted nhmmer (second iteration)

Each of the alignments for predicted RUFs are used as queries to search against the set of representative genomes in order to expand the number of sequences used and to determine the evolutionary conservation of each RUF.


do this twice

```{bash run_srna_nhmmer_loop_large_alignments, eval=F}
##done in ~/phd/RNASeq/srnas/${group}
group="predicted"
cd ~/phd/RNASeq/srnas/${group}
run_sRNA_nhmmer.sh -d ~/phd/RNASeq/representative_genomes.fna -f initial_alignments/ -o large_alignments/ -e stk -E 1e-5
```



--------



# Known sRNAs{#known_srna}

The known sRNAs are used for two purposes:

-   The ribosomal small subunit is used to calculate phylogenetic distances for each of the genomes used

-   All rFam models with sRNAs < 500 nt are used as a *positive* *control* dataset

## Find known sRNAs

###  cmscan with RFam families {#cmscan_rfam}

The RFam families were downloaded from [Rfam](https://rfam.xfam.org/):

-   Click *FTP*

    -   Select Guest as user and connect
    
    -   open Current (14.4)
    
Two files were downloaded:

-   *Rfam.cm* contains all the models for the families

    -   The *RFam.cm* file needed to be unzipped `gunzip Rfam.cm.gz`.

-   *Rfam.clanin.txt* contains clan information


These files were used to search against the set of representative genomes and analysed genomes.

```{bash run_csmscan_across_multiple_files, eval=F, include=T}
#in ~/phd/RNASeq/representative_genomes
#in ~/phd/RNASeq/analysed_genomes
mkdir check_files
for file in *.fna; 
do 

  runname=`basename $file .fna`;  

  if [ -f "check_files/${runname}.tmp.out" ]; then 
    echo "Already exists: $runname"; 
    continue;
  else 
    echo "$runname";  
  fi;  
  
  rfamscan $file;  
  > check_files/$runname.tmp.out;  

done

```

This search gave an output for each genome containing coordinates (contig, start, end, strand) for the location of sequences matching Rfam families. These files needed to be combined and reformatted so that the nucelotide sequences of the matches could be obtained. This was done for each group:

`group="representative_genomes"`

`group="analysed_genomes"`

The outputs combined with `cat *.tblout >> ../${group}.tblout`. This output was reformatted so that it could be easily read into R `cat ${group}.tblout | sed 's/  /\t/g' | tr -s '\t' | sed 's/\t /\t/g' | sed 's/ \t/\t/g' | sed 's/ /\t/3' | sed 's/ /\t/' | sed 's/ /\t/' | sed 's/ /_/g' | sed 's/_!/\t!/g' | tr -s '\t' | sed 's/Pseudomonas\t/Pseudomonas_/g' > ${group}.tab`


All of the genomes for each group were combined into one file for easier coding of the step involving getting the sequences `cat *.fna >> ../${group}.fna`

The files were then marked as completed:

`mkdir done`

`mv *.fna done/`

`mv *.tblout done/`

###  Lookup table (genomes and contigs)

The results from cmscan and nhmmer use contig accessions for the target accessions, while the genomes that were used have genome accessions. It was therefore necessary to create a lookup table of genome and contig accessions.

- done on server (biochemcompute.uod.otago.ac.nz) initially

```{bash genome_contig_pairs, eval=F}
#done from ~/phd/RNASeq/representative_genomes/

cd ~/phd/RNASeq/representative_genomes/

> ../genome_contig_pairs.txt
for file in GC*.fna;  
do   

  ID=`echo $file | cut -d '.' -f1,2 | cut -d "_" -f1,2`;   
  grep ^">" $file | cut -d ' ' -f1 | sort | uniq | sed 's/>//g' | sed -e "s/$/   $ID/" >> ../genome_contig_pairs.txt;   
done
```

`cd ~/phd/RNASeq/`

`scp bioc:./phd/RNASeq/genome_contig_pairs.txt ./`

```{bash genome_contig_pairs_analysed_genomes, eval=F}
#done from ~/phd/RNASeq/representative_genomes/
cd ~/phd/RNASeq/
for file in ./genera/*/*/GC*.fna;  
do   
echo $file
  ID=`basename $file | cut -d '.' -f1,2 | cut -d "_" -f1,2`;
  grep ^">" $file | cut -d ' ' -f1 | sort | uniq | sed 's/>//g' | sed -e "s/$/   $ID/" >> ./genome_contig_pairs.txt;   
done
```


###  Coordinates from cmsearch

The reformatted cmscan output is used to create files `${family}_locations.txt` for each of the Rfam families of  the coordinates of all the matching regions from the representative and analysed genomes.
    
-   This was done on the server (biochemcompute.uod.otago.ac.nz) using [Rstudio](http://biochemcompute.uod.otago.ac.nz:8787/) from the browser

-   representative genomes

```{r cmsearch_res_pc, eval=F}

## file made with cat RF00177.tbl | sed 's/  /\t/g' | tr -s '\t' | sed 's/\t /\t/g' | sed 's/ \t/\t/g' | sed 's/ /\t/3' | sed 's/ /\t/' | sed 's/ /\t/' | sed 's/ /_/g' | sed 's/_!/\t!/g' | tr -s '\t' | sed 's/Pseudomonas\t/Pseudomonas_/g' > RF00177.tab along with manually replacing some incorrect _ and \t 

dat <- read.table("~/phd/RNASeq/representative_genomes.tab", sep = "", quote = "", comment.char = "#", fill = T)

contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("query.name", "genome")

dat <- dat[,2:18]

colnames(dat) <- c("description.of.target", "target.name", "query.name", "accession", "accession.2", "mdl", "mdl.from", "mdl.to", "seq.from", "seq.to", "strand", "trunc", "pass", "gc", "bias", "score", "e.value")

dat <- dat %>% filter(!is.na(e.value))

dat <- dat %>% group_by(target.name, query.name) %>% 
  arrange(as.numeric(e.value)) %>% 
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()





smalldat <- dat %>% 
  select(target.name, query.name, seq.from, seq.to, strand, e.value, mdl.from, mdl.to)

smalldat <- smalldat %>% left_join(contig_labels, by = 'query.name') %>% 
  group_by(genome, target.name) %>% 
  arrange(as.numeric(e.value)) %>%
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()

RF00177 <- smalldat %>% filter(target.name == "RF00177") 


for(item in unique(smalldat$target.name)){
  print(item)
  modelDat <- smalldat %>% filter(target.name == item)
  if(nrow(modelDat) == 0){
    continue
  }
  modelDat <- modelDat %>% select(query.name, seq.from, seq.to, strand)
  
write.table(x = modelDat, file = paste("~/phd/RNASeq/rfam_files/locations/", item,"_locations.txt", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t")
  

}

  write.table(x = RF00177 %>% select(query.name, seq.from, seq.to, strand), file = "~/phd/RNASeq/rfam_files/RF00177_locations.txt", row.names = F, col.names = F, quote = F, sep = "\t")


```

-   analysed genomes

```{r cmsearch_res_analysed_genomes, eval=F}

## file made with cat RF00177.tbl | sed 's/  /\t/g' | tr -s '\t' | sed 's/\t /\t/g' | sed 's/ \t/\t/g' | sed 's/ /\t/3' | sed 's/ /\t/' | sed 's/ /\t/' | sed 's/ /_/g' | sed 's/_!/\t!/g' | tr -s '\t' | sed 's/Pseudomonas\t/Pseudomonas_/g' > RF00177.tab along with manually replacing some incorrect _ and \t 

dat <- read.table("~/phd/RNASeq/analysed_genomes.tab", sep = "", quote = "", comment.char = "#", fill = T)

contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("query.name", "genome")

dat <- dat[,2:18]

colnames(dat) <- c("description.of.target", "target.name", "query.name", "accession", "accession.2", "mdl", "mdl.from", "mdl.to", "seq.from", "seq.to", "strand", "trunc", "pass", "gc", "bias", "score", "e.value")

dat <- dat %>% filter(!is.na(e.value))

dat <- dat %>% group_by(target.name, query.name) %>% 
  arrange(as.numeric(e.value)) %>% 
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()





smalldat <- dat %>% 
  select(target.name, query.name, seq.from, seq.to, strand, e.value, mdl.from, mdl.to)

smalldat <- smalldat %>% left_join(contig_labels, by = 'query.name') %>% 
  group_by(genome, target.name) %>% 
  arrange(as.numeric(e.value)) %>%
  mutate(order.num = row_number()) %>% 
  filter(order.num == 1) %>% 
  ungroup()

RF00177 <- smalldat %>% filter(target.name == "RF00177") 


for(item in unique(smalldat$target.name)){
  print(item)
  modelDat <- smalldat %>% filter(target.name == item)
  if(nrow(modelDat) == 0){
    continue
  }
  modelDat <- modelDat %>% select(query.name, seq.from, seq.to, strand)
  
write.table(x = modelDat, file = paste("~/phd/RNASeq/analysed_genomes_rfam_files/locations/", item,"_locations.txt", sep = ""), row.names = F, col.names = F, quote = F, sep = "\t")
  

}

  write.table(x = RF00177 %>% select(query.name, seq.from, seq.to, strand), file = "~/phd/RNASeq/rfam_files/RF00177_locations.txt", row.names = F, col.names = F, quote = F, sep = "\t")


```

### Get sequences

The `${family}_locations.txt` were then used to extract the nucelotide sequence of all matching regions from each of the corresponding fasta files. 

-   The fasta files needed to be indexed with `esl-sfetch --index ${group}.fna` 

A later step ([cmalign](#section-make_cm_files)) uses a lot of memory. To keep this step managable the files were limited to 20 sequences per file, with multiple files being created for each Rfam family if needed.

-   This is [later](#section-combine_alignments) combined with `esl-alimerge`

```{bash get_nucelotide_sequences, eval = F}   

## from ~/phd/RNASeq/rfam_files/

# > RF00177_rep_seqs.fna

i=0
file_count=1
> RF00177_files/RF00177_rep_seqs_${file_count}.fna
while read line; 
do 
  i=`expr $i + 1`
  if (( $i > 50 )); then
  i=0
  file_count=`expr $file_count + 1`
  > RF00177_files/RF00177_rep_seqs_${file_count}.fna
  fi

  
  contig=`echo $line | cut -d ' ' -f1`; 
  contig_start=`echo $line | cut -d ' ' -f2`; 
  contig_end=`echo $line | cut -d ' ' -f3`; 
  contig_strand=`echo $line | cut -d ' ' -f4`;  
  
  length=`expr $contig_end - $contig_start`
  
  length=`echo $length | tr -d '-'`
  
  if (( $length < 1400 )); then
  echo "$contig too short" 
  continue
  fi

    esl-sfetch -c ${contig_start}..${contig_end} ../representative_genomes/representative_genomes.fna $contig        >> RF00177_files/RF00177_rep_seqs_${file_count}.fna;

done < RF00177_locations.txt


## from ~/phd/RNASeq/rfam_files/locations
## or
## from ~/phd/RNASeq/analysed_genomes_rfam_files/locations
for file in *_locations.txt;
do
outname=`basename $file _locations.txt`

echo $outname

i=0
file_count=1
mkdir -p ../${outname}_files/
> ../${outname}_files/${outname}_rep_seqs_${file_count}.fna
while read line; 
do 
  i=`expr $i + 1`
  if (( $i > 50 )); then
  i=0
  file_count=`expr $file_count + 1`
  > ../${outname}_files/${outname}_rep_seqs_${file_count}.fna
  fi

  
  contig=`echo $line | cut -d ' ' -f1`; 
  contig_start=`echo $line | cut -d ' ' -f2`; 
  contig_end=`echo $line | cut -d ' ' -f3`; 
  contig_strand=`echo $line | cut -d ' ' -f4`;  
  
  length=`expr $contig_end - $contig_start`
  
  length=`echo $length | tr -d '-'`
  


    esl-sfetch -c ${contig_start}..${contig_end} ../../${group}.fna $contig        >> ../${outname}_files/${outname}_rep_seqs_${file_count}.fna;

done < ${outname}_locations.txt



done < $file
done


```

### Make cm files {#make_cm_files}

The files with sequences for each rFam model need to be in stockholm alignment format which is done by running cmalign against the Rfam model.

```{bash make_cm_files, eval=F}
## from ~/phd/RNASeq/rfam_files/
## or
## ~/phd/RNASeq/analysed_genomes_rfam_files

for folder in *_files; 
do 

  
  cmmodel=`basename $folder _files`;  

  
  cmfetch  ~/phd/RNASeq/Rfam.cm $cmmodel > current.cm;
  > $folder/ali_files.txt; 
  
  
  for file in $folder/*.fna; 
  do
  
    shortname=`basename $file`;
    outname=`basename $shortname .fna`;  
    cmalign -g --dnaout -o $folder/$outname.cm current.cm $file;  
    echo "$outname.cm" >> $folder/ali_files.txt;  
    
  done;  
done

```


### Remove empty files

Some of the files do not contain sequences and cause problems for the [merging](#section-combine_alignments) step. 

-   I think this is due to some earlier mistakes creating extra empty files that were not removed


```{bash remove_empty_files, eval=F}
for folder in *_files; 
do
  cd $folder
  
  > ali_files_2.txt
  
  while read line; 
  do
  
    line_length=`wc -l $line | cut -d ' ' -f1`
    
    if (( $line_length > 0 )); then
      echo $line >> ali_files_2.txt
    fi
    
  done < ali_files.txt
  mv ali_files_2.txt ali_files.txt
  cd ..

done
```


### Combine alignments {#combine_alignments}

Once the alignments have been built, it is possible to combine these alignments with `esl-alimerge` while also masking these alignments to the original model so that the alignments are kept very similar to the rfam family, while providing coordinates of the locations of sequences for the *representative* and *analysed* genomes.


```{bash combine_alignments, eval=F}
for folder in *_files;
do
  cd $folder
  outname=`basename $folder _files`
  echo $outname
  esl-alimerge --list ali_files.txt | esl-alimask --rf-is-mask - > $outname.stk
  cd ..
  
done
```


These files are downloaded from the server:

-   `cd ~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments`

-   `scp bioc:./phd/RNASeq/rfam_files/alignments/* ./`


## Phylogenetic Distance

The bacterial ribosomal small subunit (RF00177) was used to get the phylogeneitc distances between all the genomes. This was done using [Phylip](https://evolution.genetics.washington.edu/phylip.html).

### Rename IDs

The phylip format for files uses shortened ID, limited to 10 characters. This means there needs to be a lookup table to reverse this in later steps.

```{r rename_alignment_ids, eval=F}
dat <- read.table("~/phd/RNASeq/RF00177.stk", sep = "\t", fill = T, comment.char = "", quote = "", header = F)

dat <- dat %>% separate(V1, into = c("a", "b", "c"), sep = " ", extra = 'merge', remove = F)

dat <- dat %>% mutate(id_test = ifelse(grepl(pattern = "/",x = b), T, F))


current_ids <- dat %>% filter(id_test) %>% select(b) %>% unique()

current_ids <- current_ids %>% separate(col = b, into = "id", extra = "drop", remove=F, sep = "/") %>% mutate(phylip_id = substr(x = b, start = 1, stop = 10))

write.csv(x = current_ids, file = "~/phd/RNASeq/uids_RF00177_alignment.txt", quote = F, row.names = F)
save(current_ids, file = "~/Downloads/R-master/r_files/current_ids.Rda")

```

### Reformat matrix

The phylip tool dnadist was used to create a distance matrix based on the SSU alignment.

The stockholm file was reformatted `esl-reformat phylip RF00177.stk > RF00177_rep_seqs_all.phylip` and this was used in dnadist as an input, with *RF00177_rep_seqs_all.dists* as the output. All settings used were defaults.

The matrix that is made is not in an easily useable format:

-   `cat  RF00177_rep_seqs_all.dists | tr '\n' ' ' | sed 's/ N/\nN/g' > RF00177_rep_MATRIX_all.dists`




## Negative control for matches to known elements {#check_negaitves}

Using known or predicted sRNAs for the negative control regions will reduce the effectiveness of the anaylis. Although the regions originally selected were not from these regions, after creating deep alignments some overlaps have shown up.

Similar to previous sections, the coordinates (target contig, start, end, query ID) are taken for each group.

```{bash get_ids_and_positions, eval=F, include=T}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

group='predicted'
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
> ../${group}_contig_pos.txt
for file in *.stk;
do 

  ID=`echo $file | cut -d '.' -f1,2`
  echo $ID
  grep "/" $file | grep -v "//" | cut -d ' ' -f1 | sed 's/\// /g' | sed 's/-/ /g'| cut -d '|' -f2 | sort | uniq | sed -e "s/$/ $ID/" >> ../${group}_contig_pos.txt

done

```

## Overlaps between groups

The coordinates are used to check for overlaps and a file containing the query IDs of the negative control models that matched predicted or positive control models was made.

```{r compare_groups_for_overlap, eval=F}
library(GenomicRanges)
ncdat <- read.table("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/negative_control_contig_pos.txt", sep = " ", fill = T, as.is = T)

pcdat <- read.table("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/positive_control_contig_pos.txt", fill = T, as.is = T)

preddat <- read.table("/Users/thomasnicholson/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_contig_pos.txt", fill = T, as.is = T)


reformat_data <- function(dat){

colnames(dat) <- c("contig", "start", "stop", "srna")
dat <- dat  %>% select(contig, srna, start, stop) %>% mutate(strand = "+")

dat <- dat %>% mutate(start = as.numeric(start), stop = as.numeric(stop))

dat <- dat %>% mutate(tmpstart = ifelse(start < stop, start, stop),
                      tmpend = ifelse(start > stop, start, stop))
dat <- dat %>% filter(!is.na(tmpstart))
return(dat)
}

pcdat <- reformat_data(dat = pcdat)
ncdat <- reformat_data(dat = ncdat)
preddat <- reformat_data(dat = preddat)

getOverlapIDs <- function(queryDat, targetDat){
  queryDat <- queryDat %>% arrange(start)
  targetDat <- targetDat %>% arrange(start)
query <- GRanges(seqnames = queryDat$contig,
                 ranges = IRanges(start = queryDat$tmpstart, end = queryDat$tmpend),
                  strand = queryDat$strand, query_name = queryDat$srna)

target <- GRanges(seqnames = targetDat$contig,
                 ranges = IRanges(start = targetDat$tmpstart, end = targetDat$tmpend),
                  strand = targetDat$strand, query_name = targetDat$srna)


lookup1NC <- data.frame(id1 = queryDat$srna, queryHits = c(1:length(queryDat$srna)))
lookup2PC <- data.frame(id2 = targetDat$srna, subjectHits = c(1:length(targetDat$srna)))

tmp <- GenomicRanges::findOverlaps(query, target, type = 'any')

tmp <- as.data.frame(tmp)

tmp <- tmp %>% left_join(lookup1NC) %>% left_join(lookup2PC)
tmp <- tmp %>% mutate_all(as.character)
tmp <- tmp %>% filter(id1 != id2)

smallDat <- tmp %>% select(id1, id2) %>% unique()
return(smallDat)
}

nc.pc.Dat <- getOverlapIDs(queryDat =ncdat, targetDat = pcdat)
nc.pred.Dat <- getOverlapIDs(queryDat =ncdat, targetDat = preddat)
pc.pred.Dat <- getOverlapIDs(queryDat =preddat, targetDat = pcdat)

dat <- data.frame(ids = c(nc.pc.Dat$id1, nc.pred.Dat$id1))

write.table(dat, file = "~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/not_negative_control_ids.txt", row.names = F, col.names = F, quote = F)

dat2 <- data.frame(ids =  pc.pred.Dat$id1)

write.table(dat2, file = "~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_matches_positive_control_ids.txt", row.names = F, col.names = F, quote = F)

```

## Remove sRNAs that are not negative controls

This step was done later and meant that all results needed to be removed. The sRNAs listed in the *not_negative_control_ids.txt* file were moved to an *ignore/* folder.

```{bash remove_not_nc, eval=F, include=T}
## done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/

mkdir -p RNAAlifold/keep
mkdir -p alifold/keep
mkdir -p alignments_rnaalifold/keep
mkdir -p rscape_out/keep

mkdir -p RNAAlifold/ignore_2
mkdir -p alifold/ignore_2
mkdir -p alignments_rnaalifold/ignore_2
mkdir -p rscape_out/ignore_2




while read line;
do

mv ./RNAAlifold/$line* ./RNAAlifold/ignore_2
mv ./alifold/$line* ./alifold/ignore_2
mv ./alignments_rnaalifold/$line* ./alignments_rnaalifold/ignore_2
mv ./rscape_out/$line* ./rscape_out/ignore_2

done < not_negative_control_ids.txt

```

# Remove redundancy {#remove_redundancy}

***


Each of the predicted sRNAs have been used in a search of ~1500 genomes. As there are many sRNAs each comntributing to each model, it is important to enusre that each sequence only shows up in one model rather than several. This means combining the duplicated models to remove redundancy. This will be done by getting the coordinates of each match for each contig and checking for overlapping regions and the overlapping regions will be merged.

- done on the server (biochemcompute.uod.otago.ac.nz)
    



## Redundancy example

Test example dataframe if there is a test that is needed on a small dataset.

```{python redundacy_test_example, eval=F}
test_contigs = ['N1', 'N2', 'N3', 'N4']
test_data = {'query_id':['G1', 'G2', 'G3', 'G1', 'G2', 'G3', 'G1', 'G1', 'G3', 'G3', 'G2', 'G3'], 
             'target_contig':['N1', 'N1', 'N1', 'N2', 'N2', 'N2', 'N3', 'N3', 'N3', 'N3', 'N4', 'N4'],
            'target_start':[1, 1, 2, 100, 100, 100, 940, 855, 940, 855, 1010, 1015],
            'target_end':[100, 100, 95, 180, 180, 180, 860, 935, 860, 935, 1110, 1120]}

```


## Coordinates of matches{#contigs_and_cordinates_of_matches}

From the output (stoockholm format) for each RUF, a file containing coordinates (target contig, query ID, start, end) id generated for the predicted and negative control dataset (should be done for the positive control as well).

```{bash contigs_and_cordinates_of_matches, eval=F}
## done in ~/phd/RNASeq/srnas/predicted/large_alignments/alignments

group="predicted"

cd ~/phd/RNASeq/srnas/${group}/large_alignments/alignments
> ../../${group}_genomic_sequence_matches.txt
for file in *.stk;
do 

  ID=`echo $file | cut -d '.' -f1,2`
  grep ^"#=GS" $file | sort | uniq | cut -d "[" -f1 | cut -d ' ' -f2  | cut -d '|' -f2- |  sed -e "s/$/   $ID/" >> ../../${group}_genomic_sequence_matches.txt

done
 
```

## Identify redundancy (novel predicted)

This method uses GenomicRanges and IRanges to find overlaps and save the list of overlapping models in a file using the first model as the file name. This will continue to be the model name going forward.

- done on the server (biochemcompute.uod.otago.ac.nz)

- repeated for the positive control dataset on the MacBook

```{r redundancy_1_R, eval=F}

dat <- read.table("~/phd/RNASeq/srnas/predicted/predicted_genomic_sequence_matches.txt", sep = " ", fill = T, as.is = T)

dat <- dat %>% select(V1, V4)
dat <- dat %>% separate(col = V1, into = c("contig", "coordinates"), sep = "\\/", remove = F)
dat <- dat %>% separate(col = coordinates, into = c("start", "stop"), sep = "-", remove = F)
dat <- dat %>% dplyr::rename(srna = V4) %>% select(contig, srna, start, stop) %>% mutate(strand = "+")
colnames(dat) <- c("contig","srna", "start", "stop", "strand") 

dat <- dat %>% mutate(start = as.numeric(start), stop = as.numeric(stop))

dat <- dat %>% mutate(tmpstart = ifelse(start < stop, start, stop),
                      tmpend = ifelse(start > stop, start, stop))

query <- GRanges(seqnames = dat$contig,
                 ranges = IRanges(start = dat$tmpstart, end = dat$tmpend),
                  strand = dat$strand, query_name = dat$srna)


lookup1 <- data.frame(id1 = dat$srna, queryHits = c(1:length(dat$srna)))
lookup2 <- data.frame(id2 = dat$srna, subjectHits = c(1:length(dat$srna)))


tmp <- GenomicRanges::findOverlaps(query, query, type = 'any')

tmp <- as.data.frame(tmp)

tmp <- tmp %>% left_join(lookup1) %>% left_join(lookup2)

tmp <- tmp %>% filter(id1 != id2)

smallDat <- tmp %>% select(id1, id2) %>% unique()
smallDat <- smallDat %>% mutate_all(as.character)

s2 <- smallDat
s2$id1 <- smallDat$id2
s2$id2 <- smallDat$id1

smallDat <- smallDat %>% bind_rows(s2) %>% unique()

ids <- as.character(unique(dat$srna))
item <- ids[68]
item2 <- "alignments_GCA_000017765.1_689"

groupOverlapItems <- function(smallDat, item, current_ids){
  # print(length(current_ids))
  # print(item)
  if(length(current_ids) == 0){
    current_ids <- item
  }
  df <- smallDat %>% filter(id1 == item)

  if(nrow(df) == 0){
    return(current_ids)
  }
  df$seen <- df$id2 %in% current_ids
  df <- df %>% filter(seen == F)

  if(nrow(df) == 0){
    return(current_ids)
  }
  for(item2 in df$id2){
    current_ids <- unique(c(current_ids, item2))
    current_ids <- groupOverlapItems(smallDat, item2, current_ids)
  }
  return(current_ids)
}

item <- ids[ids == "alignments_GCA_000006945.2_2627"]
tmp <- groupOverlapItems(smallDat, item, current_ids = c())

checked_ids <- c()
for(item in ids){
  if(item %in% checked_ids){
    next
  }
  print(item)
  current_ids <- groupOverlapItems(smallDat, item, current_ids = c())
 
  checked_ids <- c(checked_ids, current_ids)
  
    write.table(x = current_ids, file = paste("~/phd/RNASeq/srnas/predicted/combined_alignment_ids/", current_ids[1], "_combined_list.txt", sep = ""), append = T, quote = F, row.names = F, col.names = F)

  # mat <- as.data.frame(t(as.matrix(current_ids)))
  # write.table(mat, file = "~/phd/RNASeq/tmp/nc_overlaps", append = T, quote = F, col.names = F, row.names = F, sep = "\t")
}

```

## Identify redundancy (known predicted)

There are too many sequences in the *known_predicted* dataset for the GenomicRanges version, however as there are already models built for known sRNAs these are used instead.

Get the list of all RUFs with a match to a known sRNA model:

`cd ~/phd/RNASeq/genera`

`cat */*/*_new_calls.txt | cut -f12- | grep "RF0" > ../new_calls/all_new_calls_v2.txt`

Loop over all the known sRNAs getting all the IDs that match to each of the known sRNAs. This file (*known_predicted_models_list.txt*) can be used to get values for the predicted dataset from the positive controls.

```{bash redundancy_known_predicted, eval=F}

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/

> ./known_predicted_models_list.txt

for file in ~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/alignments/*;
do

ID=`basename $file .stk`

echo $ID

grep $ID ~/phd/RNASeq/new_calls/all_new_calls_v2.txt | cut -f2 | sort | uniq | sed -e "s/$/ $ID/"  >> ./known_predicted_models_list.txt

done

```



## Move negative control data

This quickly removes the overlapping negative controls leaving one of the models.


```{bash move_nc_quickly, eval=F, include=T}
## done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/

mkdir -p RNAAlifold/keep
mkdir -p alifold/keep
mkdir -p alignments_rnaalifold/keep
mkdir -p rscape_out/keep

mkdir -p RNAAlifold/ignore_2
mkdir -p alifold/ignore_2
mkdir -p alignments_rnaalifold/ignore_2
mkdir -p rscape_out/ignore_2


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids

for file in *.txt;
do
idname=`basename $file _combined_list.txt`

mv ../RNAAlifold/$idname* ../RNAAlifold/keep
mv ../alifold/$idname* ../alifold/keep
mv ../alignments_rnaalifold/$idname* ../alignments_rnaalifold/keep
mv ../rscape_out/$idname* ../rscape_out/keep

while read line;
do

mv ../RNAAlifold/$line* ../RNAAlifold/ignore_2
mv ../alifold/$line* ../alifold/ignore_2
mv ../alignments_rnaalifold/$line* ../alignments_rnaalifold/ignore_2
mv ../rscape_out/$line* ../rscape_out/ignore_2


done < $file

done
```

Also used for the positive control

```{bash move_pc_quickly, eval=F, include=T}
## done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/

mkdir -p RNAAlifold/keep
mkdir -p alifold/keep
mkdir -p alignments_rnaalifold/keep
mkdir -p rscape_out/keep

mkdir -p RNAAlifold/ignore_2
mkdir -p alifold/ignore_2
mkdir -p alignments_rnaalifold/ignore_2
mkdir -p rscape_out/ignore_2


cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids

for file in *.txt;
do
idname=`basename $file _combined_list.txt | cut -d '.' -f1`

mv ../RNAAlifold/$idname* ../RNAAlifold/keep
mv ../alifold/alignments_${idname}* ../alifold/keep
mv ../alignments_rnaalifold/alignments_${idname}* ../alignments_rnaalifold/keep
mv ../rscape_out/alignments_${idname}* ../rscape_out/keep

while read line;
do

mv ../RNAAlifold/$line* ../RNAAlifold/ignore_2
mv ../alifold/alignments_${line}* ../alifold/ignore_2
mv ../alignments_rnaalifold/alignments_${line}* ../alignments_rnaalifold/ignore_2
mv ../rscape_out/alignments_${line}* ../rscape_out/ignore_2


done < $file

done
```


The files in the *keep* folders are moved back out to the main working folder with `mv ./keep/* ./`

## Combine sRNAs

For the predicted data, all sequences from overlapping models are extracted, and combined into a file and this file is used to build an alinment by using hmmalign against the largest alignment from the group of alignments that are being combined.

```{bash combine_sRNAs_bash, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/combined_alignments_ids

cd ~/phd/RNASeq/srnas/predicted/combined_alignments_ids/
mkdir -p fasta
mkdir -p hmm
mkdir -p alignments

for file in *.txt;
do


max_num="0"
outname=`basename $file _combined_list.txt`
line_count=`wc -l $file | cut -d ' ' -f1`

if (( $line_count == 1 ));then

cp ../large_alignments/alignments/$outname.stk ./alignments

continue
fi

echo $outname

> fasta/$outname.fa
while read line; 
do 

esl-reformat fasta ../large_alignments/alignments/$line.stk >> fasta/$outname.fa

current_num=`esl-alistat ../large_alignments/alignments/$line.stk | grep "Number of sequences" | cut -d ' ' -f 4`

if(( $current_num > $max_num ));
then

max_seq="$line.stk"
max_num="$current_num"
fi

done < $file

hmmbuild hmm/$outname.hmm ../large_alignments/alignments/$max_seq

hmmalign --informat fasta hmm/$outname.hmm fasta/$outname.fa | esl-alimask -g --gapthresh 0.8 -p --pfract 0.5 --pthresh 0.5 - | esl-alimanip   --lnfract 0.6 --lxfract 1.4 --lmin 50 --lmax 500 --detrunc 50 - > alignments/$outname.stk

done


```

Download the alignment files from the server (biochemcompute.uod.otago.ac.nz) to  *~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments/* 

`scp bioc:./phd/RNASeq/srnas/predicted/combined_alignments_ids/alignments/* ./`

```{bash get_distribution_of_seqs_per_alignment, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold

> ../seqs_per_alignment.txt

for file in *.stk;
do

ID=`basename $file .stk | cut -d "_" -f2-`

echo $ID

seqcount=`grep "/" $file | cut -d '/' -f1  | rev | cut -d '|' -f1 | rev | sort | uniq| wc -l`

echo "$seqcount $ID" >> ../seqs_per_alignment.txt

done

```

# Score sRNAs {#score_rnas}

***

**Scripts involved for scoring the sRNAs**

-   [*run_RNAcode.sh*](#section-run_rnacode.sh)


-   [*run_RNAAlifold.sh*](#section-run_rnaalifold.sh)

    -   Produces the alignment file with predicted secondary structure included (useful for later steps) and a visualisation of the predicted secondary structure.
    
-   [*run_Alifold.sh*](#section-run_alifold.sh) 

    -   Compares the predicted secondary structure to a series of alignments from randomly shuffled sequence to give an idea of the how likley it is that the given secondary structure  could occur by chance (in the form of a z-score of the MFE).

-   [*run_R-scape.sh*](#section-run_r-scape.sh) 

    - Looks for coovaritation in the alignments.

-   [*run_rmfamscan.sh*](#section-run_rmfamscan.sh) *-e* *\<file extentsion\>* *-a*
    
    - Looks for motifs in the sRNAs

***

## RNACode {#check_negaitve_controls}

Done to check for coding potential. 

-   Run on server (*biochemcompute.uod.otago.ac.nz*)

### Summary (RNACode)

RNACode checks for protein coding sequence

`cd ~/phd/RNASeq/srnas/predicted/combined_alignments_ids`

`run_RNAcode.sh`

```{bash rnacode_summary, eval=F}
#done on server from ~/phd/RNASeq/srna_seqs/version_1/${group}/combined_alignments_ids/rnacode_out/

group="predicted"
> ../${group}.rnacode;
for file in *.rnacode;
do  
  ID=`basename $file .rnacode`; 
  cat $file | sed -e "s/$/\t$ID/"  >> ../${group}.rnacode;  
done

```

`cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments`

`scp bioc:./phd/RNASeq/srnas/predicted/combined_alignments_ids/predicted.rnacode ./`

-   formatting for R

    -   `cat negative_control.rnacode | sed 's/N/\tN/g' | grep -v "HSS" | grep -v "====" | grep -v "alignment(s) scored in" | grep -v "Delta" > tmp.rnacode`

    -   `cat predicted.rnacode | sed 's/N/\tN/g' | grep -v "HSS" | grep -v "====" | grep -v "alignment(s) scored in" | grep -v "Delta" > tmp.rnacode`

    -   `cat positive_control.rnacode | sed 's/N/\tN/g' | grep -v "HSS" | grep -v "====" | grep -v "alignment(s) scored in" | grep -v "Delta" > tmp.rnacode`

### protein_coding_filter



```{r protein_coding_filter, eval=F}
ncDat <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/tmp.rnacode",
                    col.names = c("hss.id", "frame", "length", "from", "to", "seq.name", "start", "end", "score", "p.value", "srna"), fill = T)
ncDat <- ncDat %>% mutate(p.value = as.numeric(as.character(p.value)),
                          length = as.numeric(as.character(length)))
ncDat <- ncDat %>% filter(grepl(pattern = "alignments", hss.id) == F) %>% 
  filter(p.value < 0.05, length > 16)
ncRNAcode <- ncDat
save(ncRNAcode, file = "~/Downloads/R-master/r_files/ncRNAcode.Rda")

write.table(x = ncRNAcode %>% select(srna) %>% unique(), file = "~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/remove_RNAcode.txt", quote = F, row.names = F, col.names = F)

predDat <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/tmp.rnacode",
                    col.names = c("hss.id", "frame", "length", "from", "to", "seq.name", "start", "end", "score", "p.value", "srna"), fill = T)
predDat <- predDat %>% mutate(p.value = as.numeric(as.character(p.value)),
                          length = as.numeric(as.character(length)))
predDat <- predDat %>% filter(grepl(pattern = "alignments", hss.id) == F) %>% 
  filter(p.value < 0.05, length > 16)
predRNAcode <- predDat
save(predRNAcode, file = "~/Downloads/R-master/r_files/predRNAcode_v2.Rda")



pcDat <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/tmp.rnacode",
                    col.names = c("hss.id", "frame", "length", "from", "to", "seq.name", "start", "end", "score", "p.value", "srna"), fill = T)
pcDat <- pcDat %>% mutate(p.value = as.numeric(as.character(p.value)),
                          length = as.numeric(as.character(length)))
pcDat <- pcDat %>% filter(grepl(pattern = "alignments", hss.id) == F) %>% 
  filter(p.value < 0.05, length > 16)
pcRNAcode <- pcDat


save(pcRNAcode, file = "~/Downloads/R-master/r_files/pcRNAcode.Rda")
```

-   manual made by adding accessions that I found to definity be matching to something.

-   cat remove_* >> foobar

-   cat foobar | sed 's/alignments_//g' | sort | uniq > remove_ALL.txt

### remove_negative_controls_matching_features

```{bash remove_negative_controls_matching_features, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/
mkdir -p rscape_out/ignore
mkdir -p alifold/ignore
mkdir -p RNAAlifold/ignore
mkdir -p alignments_rnaalifold/ignore

file="remove_MANUAL.txt"
while read line;
do
echo $line

mv rscape_out/*${line}*  rscape_out/ignore/
mv alifold/*${line}*  alifold/ignore/
mv RNAAlifold/*${line}*  RNAAlifold/ignore/
mv alignments_rnaalifold/*${line}*  alignments_rnaalifold/ignore/

grep -v $line query_target_pairs.txt > foobar
mv foobar query_target_pairs.txt

done < $file



file="remove_ALL.txt"
while read line;
do
echo $line

mv alifold/alignments_${line}.stk.alifold  alifold/ignore/


done < $file


```





## Phylogenetic distance 

### Lookup table (query and target)

A lookup table of  query genomes, target contigs and srna IDs was needed in later steps.

```{bash query_target_pairs, eval=F}
#done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments

group="positive_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments

> ../query_target_pairs.txt
for file in *.stk; 
do 
  
  echo $file; 
  ID=`echo $file | cut -d '.' -f1,2 | cut -d "_" -f1,2`; 
  ID_2=`echo $file | cut -d '.' -f1,2 `;  
  grep ^"#=GS" $file | sort | uniq | cut -d "/" -f1 | cut -d ' ' -f2 | rev | cut -d '|' -f1 | rev | sed -e "s/$/   $ID   $ID_2/" >> ../query_target_pairs.txt;  
  
done
```

The control groups have had some data combined (or removed) but not from the *query_target_pairs.txt* so a file with a list of IDs to keep is needed.

```{bash keep_list, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

group="negative_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

> ../${group}_keep_list.txt
for file in *.stk;
do

echo $file | cut -d '_' -f2- | rev | cut -d '.' -f2- | rev >> ../${group}_keep_list.txt

done

```


### Maximum phylogenetic distance 

The file containing the queries, targets and sRNA IDs (along with the same files for the *predicted* and *negative* *control* datasets) and the distance matrix were used to get the maximum phylogenetic distance between species for each sRNA.




```{r dna_dists_setup, eval=F, include=T}
run_all <- F
if(run_all){
dat <- read.table("~/phd/RNASeq/RF00177_rep_MATRIX_all.dists", sep = "", header = F, fill = T, stringsAsFactors = F, as.is = T)

dat <- dat %>% filter(!is.na(V2))


colnames(dat)[1] <- "phylip_id"

"NC_009791." %in% colnames(dat)

colnames(dat) <- c("names", dat$phylip_id)

# rownames(dat) <- colnames(dat)

for(i in 1:nrow(dat)){
  for(j in 2:ncol(dat)){
    # if(dat[i,1] == colnames(dat)[j]){
    #   if(dat[i,j] != 0){
    #     print(paste(i, j))
    #   }
    # }
    if(i + 1 == j){
      print(dat[i,j])
    }
  }
}

meltDat <- melt(dat)

colnames(meltDat) <- c("phylip_id", "query.name", "distance")

load(file = "~/Downloads/R-master/r_files/current_ids.Rda")
current_ids <- current_ids %>% unique()

current_ids <- current_ids %>% separate(col = id, into = c("t1", "t2"), sep = "\\|", remove = F, extra = 'warn') 

current_ids <- current_ids %>% mutate(id = ifelse(is.na(t2), t1, t2)) %>% 
  select(-t1, -t2)


contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("id", "target.genome")

contig_labels <- contig_labels %>% left_join(current_ids, by = "id") %>% select(-b)


colnames(contig_labels) <- c("target.id", "target.genome", "phylip_id")

meltDat <- meltDat %>% left_join(contig_labels, by = 'phylip_id')

colnames(meltDat)[1:2] <- c("target.name", "phylip_id")

colnames(contig_labels) <- c("query.id", "query.genome", "phylip_id")

meltDat <- meltDat %>% left_join(contig_labels, by = 'phylip_id')

ggplot() +
  geom_freqpoly(data = meltDat, aes(x = distance, y = ..count..), binwidth = 0.05)

tmp <- meltDat %>% filter(distance > 0)

ggplot() +
  geom_freqpoly(data = tmp, aes(x = distance, y = ..count..), binwidth = 0.05)

colnames(meltDat)[2] <- c("query.name")


meltDat <- meltDat %>% filter(!is.na(query.genome), !is.na(target.genome))%>% group_by(target.genome, query.genome) %>% arrange(-as.numeric(distance)) %>% mutate(row_num = row_number()) %>% filter(row_num == 1) %>% select(-row_num)

save(meltDat, file = "~/Downloads/R-master/r_files/distanceMelt.Rda")


mat <- reshape2::acast(data = meltDat %>% select(target.genome, query.genome, distance), formula = target.genome ~ query.genome)

distanceMat <- as.data.frame(mat)

save(distanceMat, file = "~/phd/RNASeq/distanceMat.Rda")

load("~/phd/RNASeq/distanceMat.Rda")

pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/query_target_pairs.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

pairs <- pairs %>% select(target.genome, ID) %>% unique()

pairs <- pairs %>% mutate_all(as.character)

# pairs <- pairs %>% filter(target.genome != "GCA_000046845.1", grepl(pattern = "GCA_000046845.1", x = ID) == F,
                          # grepl(pattern = "GCA_000015425.1", x = ID) == F)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(pairs$target.genome))


item <- 132

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

if(length(rows) == 0){
  max_val <- 0
  next
}

if(length(cols) == 0){
  max_val <- 0
  next
}

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_pred <- max_dists
save(max_dists_pred, file = "~/Downloads/R-master/r_files/max_dists_pred.Rda")



pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/large_alignments/query_target_pairs.txt")

colnames(pairs) <- c("target.name", "ID", "ID2")

pairs <- pairs %>% left_join(contig_labels, by = "target.name")

pairs <- pairs %>% mutate_all(as.character)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(dat$target.genome))


item <- 1

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_pc <- max_dists
save(max_dists_pc, file = "~/Downloads/R-master/r_files/max_dists_pc.Rda")




pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments/query_target_pairs.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

pairs <- pairs %>% select(target.genome, ID) %>% unique()

pairs <- pairs %>% mutate_all(as.character)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(pairs$target.genome))


item <- 1

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_nc <- max_dists
save(max_dists_nc, file = "~/Downloads/R-master/r_files/max_dists_nc.Rda")




pairs <- read.table("~/phd/RNASeq/srna_seqs/version_1/predicted/old/query_target_pairs_nr.txt")
colnames(pairs) <- c("target.name", "query.genome", "ID")
contig_labels <- read.table("~/phd/RNASeq/genome_contig_pairs.txt")
colnames(contig_labels) <- c("target.name", "target.genome")
pairs <- pairs %>% left_join(contig_labels, by = 'target.name')

pairs <- pairs %>% select(target.genome, ID) %>% unique()

pairs <- pairs %>% mutate_all(as.character)

srnas <- unique(pairs$ID)
max_val <- 0
max_dists <- data.frame(id = srnas, distance = NA)
counter <- 0


max_dists <- max_dists %>% mutate(complete = ifelse(is.na(distance), F, T))
length(unique(pairs$target.genome))


item <- 1

for(item in 1:nrow(max_dists)){
  printRemaining(i = item, length = nrow(max_dists), increment = 1)
  # counter <- counter + 1
  # if(counter > 5){
  #   break
  # }
  if(max_dists$complete[item] == T){
    print(paste(max_dists$id[item], "already done."))
    next
  }
  max_val <- 0
  # print(as.character(max_dists$id[item]))
  df <- pairs %>% filter(ID == as.character(max_dists$id[item])) %>% unique()
  

  if(nrow(df) == 1){
    max_val <- 0
    max_dists$distance[item] <- max_val
    max_dists$complete[item] <- T
    next
  }
genomes <- df$target.genome
rows <- match(x = genomes, table = rownames(distanceMat))
cols <- match(x = genomes, table = colnames(distanceMat))
rows <- rows[!is.na(rows)]
cols <- cols[!is.na(cols)]

max_val <- max(c(max(distanceMat[rows, cols]),max_val))

  max_dists$distance[item] <- max_val
  max_dists$complete[item] <- T
}

max_dists_pred_nr <- max_dists
save(max_dists_pred_nr, file = "~/Downloads/R-master/r_files/max_dists_pred_nr.Rda")

}
```

```{r dna_dists, eval=F, include=F}
run_all <- F
load("~/Downloads/R-master/r_files/max_dists_pred.Rda")
# load("~/Downloads/R-master/r_files/max_dists_pred_nr.Rda")
load("~/Downloads/R-master/r_files/max_dists_pc.Rda")
load("~/Downloads/R-master/r_files/max_dists_nc.Rda")



max_dists_pred <- max_dists_pred %>% mutate(group = "Predicted")
# max_dists_pred_nr <- max_dists_pred_nr %>% mutate(group = "Predicted NR")
max_dists_pc <- max_dists_pc %>% mutate(group = "Positive Control")
max_dists_nc <- max_dists_nc %>% mutate(group = "Negative Control")


dists <- max_dists_pred %>% bind_rows(max_dists_pc, max_dists_nc) %>% dplyr::rename(max_dist = distance) %>% filter(max_dist != 0)


distsCumulativeCount <- cumulativeCounts(dists = dists, smooth = F)

p <- ggplot() +
  geom_line(data = distsCumulativeCount, aes(x= max_dist, y = cumulative_prop, group = group, colour = group))
p
if(run_all){
ggsave(filename = "~/phd/RNASeq/figures/max_conservation_distance_4.svg", plot = p)
}
```

```{r large_tree, eval=F, include=F}
  # tree <- read.tree("~/Downloads/R-master/r_files/large_labelled_tree.tree")
  tree <- read.tree("~/Downloads/R-master/r_files/all_taxa.tree")
  p <-ggtree(tree) + 
  geom_tiplab() +
  xlim(0,0.8)
  p
  #ggsave(filename = "~/phd/RNASeq/figures/large_tree.svg", device = 'svg', width = 50, height = 50, limitsize = FALSE)
```





## RNAAlifold{#rnaalifold}

RNAAlifold calculates the best secondary structure, the MFE of that strucutre and gives a covariation score. The program is run using [*run_RNAAlifold.sh*](#section-run_rnaalifold.sh) in *~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/*

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/`

`run_RNAAlifold.sh`

This loops over all of the alignments (stockholm format) in the *./alignments/* folder and checks the size of the alignments (removing poor alignments and alignmnets > 500 nt). The file format is changed to clustal and runs RNAAlifold. The output alignment (alignment with secondary structure and scores) and a post-script format visual secondary structure are moved to folders. 


### Summary (RNAAlifold)

The alifold score is made up of the combination of the MFE of the structure and the covariation score. Each of these scores are written to files for each of the groups.

```{bash rnaalifold_summary, eval=F}
#done from ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/RNAALifold

group="positive_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/RNAALifold
> ../${group}_alifold_score.txt;
> ../${group}_mfe.txt;
> ../${group}_alifold_covariation.txt; 

for file in *.rnaalifold;
do   
  
  if [ $file == *"\.stk\.stk\.rnaalifold" ]; then 
    ID=`basename $file .stk.stk.rnaalifold`; 
  else 
    ID=`basename $file .stk.rnaalifold`; 
  fi; 
  grep "=" $file | rev | cut -d "(" -f1 | cut -d '{' -f1 | rev | cut -d "=" -f1 | sed -e "s/$/   $ID/"  >> ../${group}_alifold_score.txt; 
  grep "=" $file | rev | cut -d "(" -f1 | grep -v '{'| rev | cut -d "=" -f2 | cut -d "+" -f1 | sed -e "s/$/   $ID/" >> ../${group}_mfe.txt; 

  grep "=" $file | rev | cut -d "(" -f1 | grep -v '{' | rev | cut -d "=" -f2 | cut -d "+" -f2 | tr -d ")" | sed -e "s/$/   $ID/" >> ../${group}_alifold_covariation.txt; 

done
```

-   Positive control set has different naming and needs the files moved with another step

####  positive_control_alignments

```{bash move_positive_control_alignments, eval=F}
for file in alignments_R*;
do
  outname=`basename $file .stk.stk`
  mv $file alignments_rnaalifold/$outname.stk
done
```

-   Negative control set has different naming and needs the files moved with another step

####  negative_control_alignments

```{bash move_negative_control_alignments, eval=F}
for file in alignments_a*;
do
tmpname=`echo $file | cut -d '_' -f2,3,4,5`
  outname=`basename $tmpname .stk.stk`
  mv $file alignments_rnaalifold/$outname.stk
done
```


## Rscape

Rscape idenitfies covariation, looking for paris of columns in an alignment that co-vary. The program is run using [*run_R-scape.sh*](#section-run_r-scape.sh) in *~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/*

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/`

`run_R-scape.sh`

Like the [RNAAlifold](#section-rnaalifold) loop, this checks each alignment and runs the R-scape program. The alignments used are the output alignments from [RNAAlifold](#section-rnaalifold).

### Summary (R-scape)

All of the covariation scores are written to files for each of the groups.

```{bash rscape_summary,eval=F}
#done from ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/rscape_out/

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/rscape_out/
> ../${group}.rscape.cov;
for file in *.sorted.cov;
do  
  tmpname=`echo $file | cut -d '_' -f2,3,4`; 
  ID=`basename $tmpname .stk.stk`; 
  cat $file | sed -e "s/$/	$ID/"  >> ../${group}.rscape.cov;  
done

```


## Alifoldz


Alifoldz takes the alifold score from RNAAlifold and shuffles the sequence and calculates the same alifold score ont he shuffled sequences. This allows a z-score of the alifold score to be calculated and used. The program is run using [*run_Alifold.sh*](#section-run_alifold.sh) in *~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/*

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/`

`run_Alifold.sh`

Like the [RNAAlifold](#section-rnaalifold) loop, this checks each alignment and runs the Alifoldz program. The alignments used are the output alignments from [RNAAlifold](#section-rnaalifold).


### Summary (Alifoldz)

All of the z-scores are written to files for each of the groups.

```{bash alifold_summary, eval=F}
#done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alifold 
group="negative_control"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alifold 
> ../${group}.alifold
for file in *.alifold;  
do 

  ID=`echo $file | cut -d '.' -f1,2`; 
  grep -v "#" $file | grep -v "From" | grep -v "\-\-\-" | tr -s ' '  | sed -e "s/$/   $ID/" >> ../${group}.alifold
  
done

```

## rmFam

Searches for RNA motifs in alignments.

`cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold`

`run_rmfamscan.sh`


### rmfamscan_summary

```{bash rmfamscan_summary, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/rmfam_gff_files

group='predicted'
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold/rmfam_gff_files
> ../../${group}.rmfam;  
for file in *.gff;    
do    
tmpname=`echo $file | sed 's/\.clustal//g'`;  
ID=`basename $tmpname .stk.stk.gff`;  
grep -v "#" $file | sed -e "s/$/   $ID/" >> ../../${group}.rmfam;  
done

```


## GC content

```{bash gc_content_simple, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

> ./${group}_gc_all.txt

for file in ./alignments_rnaalifold/*;
do

ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

esl-reformat fasta ${file}  | grep -v ^">" | grep -o . | sort | uniq -c | sed -e "s/$/ $ID/" >> ${group}_gc_all.txt


done


```


### Genome GC percentage

Run on server (*biochemcompute.uod.otago.ac.nz*):

```{bash gc_content_genome, eval=F}
## done in ~/phd/RNASeq/representative_genomes/


cd ~/phd/RNASeq/representative_genomes/

> ../gc_genomes.txt

for file in *.fna;
do

ID=`basename $file .fna | cut -d '_' -f1,2`; 

echo $ID

cat ${file}  | grep -v ^">" | grep -o . | sort | uniq -c | sed -e "s/$/ $ID/" >> ../gc_genomes.txt


done


```

`grep "GCA_" gc_genomes.txt > gc_genomes_analysed.txt`


Download to Macbook:

-  `cd ~/phd/RNASeq`

-   `scp bioc:./phd/RNASeq/gc_genomes_analysed.txt ./`


### Reference GC percentage


```{bash get_reference_fasta, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/

> ./${group}_gc_reference.txt

for file in ./alignments_rnaalifold/*;
do

ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

cat $file | grep "#=GC RF" | cut -d ' ' -f3-  | tr -d ' ' |  grep -o . | sort | uniq -c | sed -e "s/$/ $ID/" >> ./${group}_gc_reference.txt

done
```

-   GC percentage is calculated from the _rf.fna file using:

    -   sRNAGCPercentage.py -i ${group}_rf.fna -o ${group}_rf.gc

## get RNA labels from Rfam {#get_rna_labels}

```{bash get_rna_labels, eval=F}
> rfam_descriptions.txt
for folder in *_files;
do
outname=`basename $folder _files`
echo $outname
description=`cmfetch  ~/phd/RNASeq/Rfam.cm $outname | grep ^"NAME" | head -n 1 | tr -s ' ' | cut -d ' ' -f2-`

echo "${outname} ${description}" >> rfam_descriptions.txt

done
```

### view_rfam_descriptions


```{r view_rfam_descriptions}
rfam <- read.table("~/phd/RNASeq/srna_seqs/version_1/positive_control/rfam_descriptions.txt", sep = " ")

```



## sRNA_read_depths


### sRNA_read_depths_script


```{bash sRNA_read_depths, eval=F, include=T}
## Done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
group='positive_control'
if [[ $group ==  'positive_control' ]];
then
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/analysed_genomes/alignments
> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary_ALL_reads.txt
else
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary.txt
fi

#file=alignments_GCA_000006765.1_12.stk
for file in *.stk;
  do
  genome_name=`echo $file | cut -d '_' -f2,3`
  ID=`echo $file | cut -d '_' -f2,3,4 | sed 's/\.stk//g'`
  
  cat $file | grep -v ^"#" | grep "/" | grep -v "//" | cut -d ' ' -f1 > ~/phd/RNASeq/tmp/tmp.txt
  while read line; 
    do
    contig=`echo $line | cut -d '/' -f1 | rev | cut -d '|' -f1 | rev`
    coord=`echo $line | cut -d '/' -f2`
    realstart=`echo $coord | cut -d '-' -f1`
    realstop=`echo $coord | cut -d '-' -f2`
    start=`echo $coord | cut -d '-' -f1`
    stop=`echo $coord | cut -d '-' -f2`    
    #echo $contig
    genome=`grep $contig ~/phd/RNASeq/sequences/contig_ids_accession.lookup | cut -f2`
    genus=`grep $contig ~/phd/RNASeq/contig_descriptions.txt | cut -f2 | cut -d '_' -f1`
#    if [[ $genome != $genome_name ]]; then
#      continue
#    fi
    stats=`esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna`
    esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna | grep "=" > ~/phd/RNASeq/tmp/tmp.stats
    current_count=0
    while read stat_line;
      do
      chromosome=`echo "$stat_line" | grep $contig | wc -l | cut -d ' ' -f8`
      if (( $chromosome > 0 ));
        then
        tmpstart=$(($start + $current_count))
        tmpstop=$(($stop + $current_count))
        if (( $tmpstart < $tmpstop  )); then
          start=$tmpstart
          stop=$tmpstop
        else
          stop=$tmpstart
          start=$tmpstop
        fi
        
        if [[ ! -d ~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files ]];
          then
          echo "Genome: ${genome} has no plot files"
          continue
        fi
        #echo "~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files $start $stop"
        > ~/phd/RNASeq/tmp/test.plot
        counter="1"
        for plotfile in ~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files/*.plot;
          do
          if [[ $plotfile == *"ncRNA"* ]]; then
            continue
          elif [[ $plotfile == *"rev"* ]]; then
            continue
          elif [[ $plotfile == *"fwd"* ]]; then
            continue            
          fi
          echo "$plotfile $genus $genome"
          sed -n "${start},${stop}{p;${stop}q;}"  $plotfile > ~/phd/RNASeq/tmp/tmp.plot
          if [[  $counter ==  "1" ]];
          then
            cat ~/phd/RNASeq/tmp/tmp.plot > ~/phd/RNASeq/tmp/test.plot
            counter="2"
          else
            cat ~/phd/RNASeq/tmp/test.plot > ~/phd/RNASeq/tmp/tmp2.plot 
            paste ~/phd/RNASeq/tmp/tmp2.plot ~/phd/RNASeq/tmp/tmp.plot > ~/phd/RNASeq/tmp/test.plot
          fi
        done
        #cp test.plot ~/phd/RNASeq/tmp
        summarise_sRNA_read_depths.R ~/phd/RNASeq/tmp/test.plot
        cat ~/phd/RNASeq/tmp/test.values | sed -e "s/$/ $ID $genus $genome_name $genome $contig $realstart $realstop $start $stop/" >> ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/${group}_read_depths_summary.txt
      else
        length=`echo $stat_line | cut -d ' ' -f3`
        current_count=$(($current_count + $length))
      fi
      
    done < ~/phd/RNASeq/tmp/tmp.stats
  done < ~/phd/RNASeq/tmp/tmp.txt
done
```

### sRNA_read_depths_predicted


-   Get read depths for the originally predicted sRNAs

```{bash sRNA_read_depths_predicted, eval=F, include=T}
## done in ~/phd/RNASeq/genera/
#${genera}/${accession}.data

#cd ~/phd/RNASeq/genera/
#> ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_reads_from_new_calls.txt
#for genera in *;
#do
genera="Lysobacter"
echo $genera

> ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_reads_${genera}.txt


cd ~/phd/RNASeq/genera/${genera}/

for folder in *.data;
do
  accession=`basename $folder .data`
  cd ~/phd/RNASeq/genera/${genera}/${accession}.data
  echo $accession
  
  while read line;
  do
    #echo $line
    contig=`echo $line | cut -d ' ' -f1`
    if [[ $contig == "sequence"  ]]; then
      continue
    fi
    #coord=`echo $line | cut -d '/' -f2`
    realstart=`echo $line | cut -d ' ' -f3`
    realstop=`echo $line | cut -d ' ' -f4`
    start=`echo $line | cut -d ' ' -f3`
    stop=`echo $line | cut -d ' ' -f4` 
    ID=`echo $line | cut -d ' ' -f13`
    genome=`echo $ID | cut -d "_" -f1,2`
    echo "${genome} ${contig} (${ID}): ${realstart}-${realstop}"
    stats=`esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna`
    esl-seqstat -a ~/phd/RNASeq/sequences/${genome}.fna | grep "=" > ~/phd/RNASeq/tmp/${genera}_tmp.stats
    current_count=0
    while read stat_line;
      do
      chromosome=`echo "$stat_line" | grep $contig | wc -l | cut -d ' ' -f8`
      if (( $chromosome > 0 ));
        then
        tmpstart=$(($start + $current_count))
        tmpstop=$(($stop + $current_count))
        if (( $tmpstart < $tmpstop  )); then
          start=$tmpstart
          stop=$tmpstop
        else
          stop=$tmpstart
          start=$tmpstop
        fi
        
        if [[ ! -d ~/phd/RNASeq/genera/${genera}/${genome}.data/plot_files ]];
          then
          echo "Genome: ${genome} has no plot files"
          continue
        fi
        #echo "~/phd/RNASeq/genera/${genus}/${genome}.data/plot_files $start $stop"
        > ~/phd/RNASeq/tmp/test.plot
        counter="1"
        for plotfile in ~/phd/RNASeq/genera/${genera}/${genome}.data/plot_files/*.plot;
          do
          if [[ $plotfile == *"ncRNA"* ]]; then
            continue
          elif [[ $plotfile == *"rev"* ]]; then
            continue
          elif [[ $plotfile == *"fwd"* ]]; then
            continue            
          fi
          echo "$plotfile $genera $genome"
          sed -n "${start},${stop}{p;${stop}q;}"  $plotfile > ~/phd/RNASeq/tmp/${genera}_tmp.plot
          if [[  $counter ==  "1" ]];
          then
            cat ~/phd/RNASeq/tmp/${genera}_tmp.plot > ~/phd/RNASeq/tmp/${genera}_test.plot
            counter="2"
          else
            cat ~/phd/RNASeq/tmp/${genera}_test.plot > ~/phd/RNASeq/tmp/${genera}_tmp2.plot 
            paste ~/phd/RNASeq/tmp/${genera}_tmp2.plot ~/phd/RNASeq/tmp/${genera}_tmp.plot > ~/phd/RNASeq/tmp/${genera}_test.plot
          fi
        done
        #cp test.plot ~/phd/RNASeq/tmp
        summarise_sRNA_read_depths.R ~/phd/RNASeq/tmp/${genera}_test.plot
        cat ~/phd/RNASeq/tmp/test.values | sed -e "s/$/ $ID $genera $genome_name $genome $contig $realstart $realstop $start $stop/" >> ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/predicted_read_depths_summary_reads_${genera}.txt
      else
        length=`echo $stat_line | cut -d ' ' -f3`
        current_count=$(($current_count + $length))
      fi
      
    done < ~/phd/RNASeq/tmp/${genera}_tmp.stats
  done < ${accession}_new_calls.txt
  
done

#done

```

### combine_predicted_read_depths


```{bash combine_predicted_read_depths, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments
> predicted_read_depths_summary_new_calls.txt
cat predicted_read_depths_summary_reads_* | cut -d ' ' -f1,2,3 >> predicted_read_depths_summary_new_calls.txt


```


### srna_read_depths_new_calls_pc


```{bash srna_read_depths_new_calls_pc, eval = F}

genera="Escherichia"
echo $genera



cd ~/phd/RNASeq/genera/${genera}/

for folder in *.data;
do
  accession=`basename $folder .data`
  cd ~/phd/RNASeq/genera/${genera}/${accession}.data
  echo $accession
  
  cp gff_files/${accession}.gff ./
  
  cmscanToGffWrapper.R -f ${accession}.tblout -g ${accession}
  
  mv *.gff gff_files
  
  combine_gff_files.R -f ./gff_files/ -o ${accession}
  
done

```

### match_pc_pred_ids


```{bash match_pc_pred_ids, eval=F}
## done in ~/phd/RNASeq/genera

cd ~/phd/RNASeq/genera
cat */*/*_new_calls.txt | cut -f12- | grep "RF0" > ../new_calls/all_new_calls.txt

## done in ~/phd/RNASeq/genera
cd ~/phd/RNASeq/new_calls

while read line;
do
#echo $line


pcids=`echo $line | rev | cut -d ' ' -f2- | rev`
predid=`echo $line | rev | cut -d ' ' -f1 | rev`

echo $pcids | tr , '\n' | sed -e "s/$/   $predid/" | grep -v "=" | grep "RF" | sort | uniq >> ~/phd/RNASeq/pc_pred_ids.txt

done < ../new_calls/all_new_calls.txt

```



### summarise_sRNA_read_depths.R




```{r summarise_sRNA_read_depths.R, eval=F, include=T}
#!/usr/bin/env Rscript
library(dplyr, quietly = T, warn.conflicts = F)
dat <- read.table("~/phd/RNASeq/tmp/test.plot")

valuesDat <- dat %>%
  summarise_all(list(max)) %>% as.matrix() %>% t()

values <- valuesDat[,1]
outDat <- data.frame(mean = mean(values), max  = max(values))

write.table(x = outDat, file = "~/phd/RNASeq/tmp/test.values", row.names = F, col.names = F, quote = F)
```

## sRNA counts

```{bash srna_counts, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold

group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold


> ../${group}_snra_counts.txt

for file in *.stk;
do
ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

esl-alistat $file  | grep "Number of sequences" | rev | cut -d ' ' -f1 | rev | sed -e "s/$/ $ID/" >> ../${group}_snra_counts.txt

done

```

```{bash srna_pid, eval=F}
## done in ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold
#group="negative_control"
#group="positive_control"
group="predicted"
cd ~/phd/RNASeq/srna_seqs/version_1/${group}/large_alignments/alignments_rnaalifold


> ../${group}_snra_pid.txt

for file in *.stk;
do
ID=`basename $file | cut -d '.' -f1,2 | cut -d '_' -f2-`; 

echo $ID

esl-alistat $file  | grep "Average identity" | rev | cut -d ' ' -f1 | rev | sed -e "s/$/ $ID/" | tr -d '%' >> ../${group}_snra_pid.txt

done

```


Done on server

```{bash redundant_counts, eval=F}
## done in ~/phd/RNASeq/srnas/${group}/combined_alignments_ids

group="predicted"
cd ~/phd/RNASeq/srnas/${group}/combined_alignments_ids

wc -l * | grep "GCA" | cut -d '_' -f1,2,3 > ${group}_counts.txt

```

`cd ~/phd/RNASeq/srna_seqs/version_1/negative_control/large_alignments`

`scp bioc:~/phd/RNASeq/srnas/negative_control/combined_alignments_ids/negative_control_counts.txt ./`


## Images


```{bash, eval=F}

cd -p ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold/

mkdir -p post_script
mkdir -p RNAfold

for file in *.stk;
do
ID=`echo $file | cut -d '_' -f2- | sed 's/\.stk//g'`

echo $ID

esl-reformat fasta $file  | RNAfold  > ./RNAfold/${ID}.rnafold
move_file='T'
for figure in *.ps;
do

if [[ $move_file == 'T' ]]; then
mv $figure ./post_script/${ID}.ps
move_file='F'
else

continue

fi
done
done

```


```{bash check_for_matches_to_rfam, eval=F}

cd ~/phd/RNASeq/srna_seqs/version_1/predicted/large_alignments/alignments_rnaalifold 

#mkdir -p hmmscan_out
mkdir -p cmscan_out

for file in *.stk
do

ID=`echo $file | cut -d '_' -f2- | cut -d '.' -f1,2`
echo $ID

writeseqs $ID

#hmmscan --tblout hmmscan_out/${ID}.tbl ~/Downloads/Rfam.hmm ${ID}.fna > hmmscan_out/${ID}.out
cmscan --cut_ga --rfam --nohmmonly --tblout cmscan_out/${ID}.tbl --fmt 2 --clanin ~/Downloads/Rfam.clanin.txt ~/Downloads/Rfam.cm ${ID}.fna > cmscan_out/${ID}.out
done



```

